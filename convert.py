# **************************************************************************
# *
# * Authors:     J.M. De la Rosa Trevin (jmdelarosa@cnb.csic.es)
# *
# * Unidad de  Bioinformatica of Centro Nacional de Biotecnologia , CSIC
# *
# * This program is free software; you can redistribute it and/or modify
# * it under the terms of the GNU General Public License as published by
# * the Free Software Foundation; either version 2 of the License, or
# * (at your option) any later version.
# *
# * This program is distributed in the hope that it will be useful,
# * but WITHOUT ANY WARRANTY; without even the implied warranty of
# * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# * GNU General Public License for more details.
# *
# * You should have received a copy of the GNU General Public License
# * along with this program; if not, write to the Free Software
# * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
# * 02111-1307  USA
# *
# *  All comments concerning this program package may be sent to the
# *  e-mail address 'jmdelarosa@cnb.csic.es'
# *
# **************************************************************************
"""
This module contains converter functions related to Spider
"""

import numpy

from pyworkflow.em.constants import NO_INDEX, ALIGN_2D, ALIGN_3D, ALIGN_PROJ
from pyworkflow.em.convert import ImageHandler
from pyworkflow.utils.path import moveFile

from spider import SpiderDocFile, runTemplate
from os.path import splitext, split
   
    

SHIFTX = 'shiftx'
SHIFTY = 'shifty'

ANGLE_PSI = 'psi' # in-plane, xmipp psi
ANGLE_THE = 'the' # tilt in xmipp
ANGLE_PHI = 'phi' # rot in xmipp

FLIP = 'flip'


def locationToSpider(index, filename):
    """ Convert an index and filename location
    to a string with @ as expected in Spider.
    """
    #TODO: Maybe we need to add more logic dependent of the format
    if index != NO_INDEX:
        return "%s@%d" % (filename, index)
    
    return filename

def spiderToLocation(spiderFilename):
    """ Return a location (index, filename) given
    a Spider filename with the filename@index structure. """
    if '@' in spiderFilename:
        filename, index = spiderFilename.split('@')
        return int(index), str(filename)
    else:
        return NO_INDEX, str(spiderFilename)


def writeSetOfImages(imgSet, stackFn, selFn):
    """ This function will write a SetOfMicrographs as a Spider stack and selfile.
    Params:
        imgSet: the SetOfMicrograph instance.
        stackFn: the filename where to write the stack.
        selFn: the filename of the Spider selection file.
    """
    ih = ImageHandler()
    doc = SpiderDocFile(selFn, 'w+')

    for i in range(imgSet.getSize()):
        doc.writeValues(i+1)

    imgSet.writeStack(stackFn, applyTransform=True)
        
    doc.close()
    
    convertEndian(stackFn, imgSet.getSize())
    
    
def convertEndian(stackFn, stackSize):
    """ Convert the stack file generated by Xmipp
    to one that Spider likes more.
    Params:
        stackFn: the filename of the images stack
        stackSize: the number of particles in the stack
    """
    fn, ext = splitext(stackFn)
    fnDir, fnBase = split(fn)
    # Change to BigEndian
    runTemplate('cp_endian.spi', ext[1:], 
              {'[particles]': fnBase + '@******',
               '[particles_big]': fnBase + '_big@******',
               '[numberOfParticles]': stackSize
               }, cwd=fnDir)
    moveFile(fn + '_big' + ext, stackFn)
    
    
#-------------- Geometry conversions -----------------

def geometryFromMatrix(matrix, inverseTransform):
    from pyworkflow.em.transformations import translation_from_matrix, euler_from_matrix
    from numpy import rad2deg
    if inverseTransform:
        from numpy.linalg import inv
        matrix = inv(matrix)
        shifts = -translation_from_matrix(matrix)
    else:
        shifts = translation_from_matrix(matrix)
    rawAngles = -rad2deg(euler_from_matrix(matrix, axes='szyz'))
    
    # Try to have always possitives angles
    #angles = [a + 360 if a < 0 else a for a in rawAngles]
    angles = rawAngles
    
    return shifts, angles


def matrixFromGeometry(shifts, angles, inverseTransform):
    """ Create the transformation matrix from a given
    2D shifts in X and Y...and the 3 euler angles.
    """
    from pyworkflow.em.transformations import euler_matrix
    from numpy import deg2rad
    radAngles = -deg2rad(angles)

    M = euler_matrix(radAngles[0], radAngles[1], radAngles[2], 'szyz')
    if inverseTransform:
        from numpy.linalg import inv
        M[:3, 3] = -shifts[:3]
        M = inv(M)
    else:
        M[:3, 3] = shifts[:3]

    return M


def rowToAlignment(alignmentRow, alignType):
    """
    is2D == True-> matrix is 2D (2D images alignment)
            otherwise matrix is 3D (3D volume alignment or projection)
    invTransform == True  -> for xmipp implies projection
        """
    is2D = alignType == ALIGN_2D
    inverseTransform = alignType == ALIGN_PROJ
    
    if _containsAny(alignmentRow, ALIGNMENT_DICT):
        alignment = Transform()
        angles = numpy.zeros(3)
        shifts = numpy.zeros(3)
        shifts[0] = alignmentRow.getValue(xmipp.MDL_SHIFT_X, 0.)
        shifts[1] = alignmentRow.getValue(xmipp.MDL_SHIFT_Y, 0.)
        if not is2D:
            angles[0] = alignmentRow.getValue(xmipp.MDL_ANGLE_ROT, 0.)
            angles[1] = alignmentRow.getValue(xmipp.MDL_ANGLE_TILT, 0.)
            shifts[2] = alignmentRow.getValue(xmipp.MDL_SHIFT_Z, 0.)
            angles[2] = alignmentRow.getValue(xmipp.MDL_ANGLE_PSI, 0.)
        else:
            psi = alignmentRow.getValue(xmipp.MDL_ANGLE_PSI, 0.)
            rot = alignmentRow.getValue(xmipp.MDL_ANGLE_ROT, 0.)
            if rot !=0. and psi !=0:
                print "HORROR rot and psi are different from zero in 2D case"
            angles[0] = alignmentRow.getValue(xmipp.MDL_ANGLE_PSI, 0.) +\
                        alignmentRow.getValue(xmipp.MDL_ANGLE_ROT, 0.)
        flip = alignmentRow.getValue(xmipp.MDL_FLIP)
        #if alignment
        matrix = matrixFromGeometry(shifts, angles, inverseTransform)
##
        if flip:
            if alignType==ALIGN_2D:
                matrix[0,:2] *=  -1.#invert only the first two columns keep x
                matrix[2,2]   =  -1.#set 3D rot
            elif alignType==ALIGN_3D:
                matrix[0,:3] *= -1.#now, invert first line excluding x
                matrix[3,3] *= -1.
            else:
                matrix[0,:4] *= -1.#now, invert first line including x
##
        alignment.setMatrix(matrix)
        
        #FIXME: now are also storing the alignment parameters since
        # the conversions to the Transform matrix have not been extensively tested.
        # After this, we should only keep the matrix 
        #for paramName, label in ALIGNMENT_DICT.iteritems():
        #    if alignmentRow.hasLabel(label):
        #        setattr(alignment, paramName, alignmentRow.getValueAsObject(label))    
    else:
        alignment = None
    
    return alignment


def alignmentToRow(alignment, alignmentRow, alignType):
    """
    is2D == True-> matrix is 2D (2D images alignment)
            otherwise matrix is 3D (3D volume alignment or projection)
    invTransform == True  -> for xmipp implies projection
                          -> for xmipp implies alignment
    """
    is2D = alignType == ALIGN_2D
    inverseTransform = alignType == ALIGN_PROJ
    #only flip is meaninfull if 2D case
    #in that case the 2x2 determinant is negative
    flip = False
    matrix = alignment.getMatrix()
    
    if alignType == ALIGN_2D:
        #get 2x2 matrix and check if negative
        flip = bool(numpy.linalg.det(matrix[0:2,0:2]) < 0)
        if flip:
            matrix[0,:2] *= -1.#invert only the first two columns keep x
            matrix[2,2]   =  1.#set 3D rot
        else:
            pass

    elif alignType==ALIGN_3D:
        flip = bool(numpy.linalg.det(matrix[0:3,0:3]) < 0)
        if flip:
            matrix[0,:4] *= -1.#now, invert first line including x
            matrix[3,3]   =  1.#set 3D rot
        else:
            pass

    else:
        flip = bool(numpy.linalg.det(matrix[0:3,0:3]) < 0)
        if flip:
            matrix[0,:4] *= -1.#now, invert first line including x
    shifts, angles = geometryFromMatrix(matrix, inverseTransform)
    alignmentRow[SHIFTX] = -shifts[0]
    alignmentRow[SHIFTY] = -shifts[1]
    
    if is2D:
        angle = angles[0] + angles[2]
        alignmentRow[ANGLE_PSI] = angle
    else:
        #if alignType == ALIGN_3D:
        alignmentRow[ANGLE_PHI] = angles[0]
        alignmentRow[ANGLE_THE] = angles[1]
        alignmentRow[ANGLE_PSI] = -angles[2]
        
    alignmentRow[FLIP] = -1 if flip else 1
    
    